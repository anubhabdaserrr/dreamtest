<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Dream Themes from 44,000 Reddit Posts | A network of dream content</title>

  <!-- Meta tags for SEO -->
  <meta name="description"
    content="Uncovered 217 dream topics, grouped into 22 themes from 44,000 dreams on Reddit, using BERTopic to reveal hidden patterns in the contents of our dream">
  <meta name="keywords"
    content="dream analysis, AI dream analysis, social media dreams, dream themes, NLP dreams, dream content network, BERTopic dreams">
  <meta name="robots" content="index, follow">

  <!-- Open Graph for social media -->
  <meta property="og:title" content="Mapping 44,000 Dreams from Reddit: A Network of Common Dream Themes">
  <meta property="og:description"
    content="From 44,000 Reddit dreams, we uncovered 217 topics grouped into 22 themes using deep learning ‚Äî revealing the underlying architecture of what we dream.">
  <meta property="og:image" content="https://live.staticflickr.com/65535/54615848670_6784b5517c_h.jpg">
  <meta property="og:url" content="https://social-dynamics.net/dreamscatch/viz.html">

  <!-- Schema.org structured data -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebPage",
    "name": "Dream Themes from 44,000 Reddit Posts | BERTopic Analysis",
    "description": "217 topics and 22 themes uncovered from 44,000 Reddit dreams using BERTopic to explore what we usually dream of.",
    "url": "https://social-dynamics.net/dreamscatch/viz.html"
  }
  </script>

  <link rel="icon"
    href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üí≠</text></svg>">
  <link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@400;600&display=swap" rel="stylesheet">
  <!-- <script src="https://d3js.org/d3.v7.min.js"></script> -->
  <script src="./dream-network-d3.js"></script>
  <style>
    #loading-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background-image: linear-gradient(#1F2023, #424472);
      /* match site theme */
      color: white;
      z-index: 99999;
      display: flex;
      justify-content: center;
      align-items: center;
      font-family: 'Quicksand', Arial, sans-serif;
      flex-direction: column;


    }

    .svg-icon path {
      fill: #4f0809;
    }

    @keyframes pulseGlow {

      0% {
        filter: drop-shadow(0 0 2px gold) drop-shadow(0 0 4px goldenrod);
      }

      50% {
        filter: drop-shadow(0 0 6px gold) drop-shadow(0 0 12px goldenrod);
      }

      100% {
        filter: drop-shadow(0 0 2px gold) drop-shadow(0 0 4px goldenrod);
      }
    }

    .glow-pulse {
      animation: pulseGlow 3s ease-in-out infinite;
    }

    a {
      color: inherit;
      text-decoration: none;
    }

    html {
      background-image: linear-gradient(#1F2023, #424472);
    }

    body {
      /* height: calc(var(--vh, 1vh) * 100); */
      /* min-height: 100vh;
  width: 100vw;
  overflow-x: hidden;
  overflow-y: auto; */

      /* height: 100vh; */
      /* overflow: hidden;    */
      /* width: 100vw; */


      /* overflow-x: hidden;
      overflow-y: auto; */


      /* overflow: hidden; */
      font-family: "Quicksand", Arial, sans-serif;
      /*Helvetica, Georgia, serif;*/

    }

    .light {
      /* height: 10vh;
  width: 70vw; */
      z-index: 0;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      overflow: hidden;
      z-index: 0;
      height: calc(var(--vh, 1vh) * 100);
      /* height: 100%;
      width: 100%;
      position: fixed; relative */

      &:after,
      &:before {
        content: "";
        display: block;
        position: absolute;
        z-index: 0;
        pointer-events: none;
        /* background-size: cover; */
      }

      &::before {
        width: 120%;
        height: 120%;
        top: 40%;
        left: -25%;
        background: radial-gradient(48.58% 48.58% at 49.96% 59.07%, #927CFF 0%, rgba(142, 133, 190, 0.4) 43.23%, rgba(59, 61, 70, 0) 100%);
      }

      &::after {
        width: 120%;
        height: 100%;
        top: 65%;
        left: 25%;
        background: radial-gradient(48.58% 48.58% at 49.96% 59.07%, #FFF38B 0%, rgba(180, 174, 113, 0.45) 38.02%, rgba(59, 61, 70, 0) 100%);
      }
    }

    .star1 {
      animation: 3s linear 1s infinite alternate twinkle;
    }

    .star2 {
      animation: 4s linear 0s infinite alternate twinkle;
    }

    .star3 {
      animation: 3.5s linear 0.5s infinite alternate twinkle;
    }

    .star4 {
      animation: 1.25s linear 1.5s infinite alternate twinkle;
    }

    .star5 {
      animation: 4s linear 2s infinite alternate twinkle;
    }

    .star6 {
      animation: 2.5s linear 1s infinite alternate twinkle;
    }

    .star1,
    .star2,
    .star3,
    .star4,
    .star5,
    .star6 {
      pointer-events: none;
      z-index: 0;
    }

    @keyframes twinkle {
      0% {
        opacity: 1;
      }

      50% {
        opacity: 0;
      }

      100% {
        opacity: 1;
      }
    }

    /* Nice colors: 4f0809 5D1451 4B0082 6B4226 */

    svg {
      display: block;
      margin: 0 auto;
      /* position: relative; */
      z-index: 1;

      pointer-events: all;
      touch-action: manipulation;
    }

    .node-border {
      stroke: #4f0809;
      stroke-width: 5px;
      /* filter: drop-shadow(0 0 2px #FAD6A5) drop-shadow(0 0 4px #FAD6A5); */
    }

    #card {
      pointer-events: none;
      position: absolute;
      z-index: 2;
    }


    /* .link {
      stroke: #888;
    } */

    text {
      font-size: 12px;
      pointer-events: none;
    }

    image {
      pointer-events: none;
    }

    .hover-card {
      position: absolute;
      pointer-events: none;
      /* width: 280px; */
      /* background: white; */
      /* border-radius: 10px; */
      /* box-shadow: 0 4px 10px rgba(0,0,0,0.15); */
      overflow: hidden;
      display: none;
      z-index: 1000;
      transition: opacity 0.2s ease-in-out;
      /* transition: opacity 0.2s ease; */
    }

    .top-left-overlay {
      position: absolute;
      top: 0.3rem;
      left: 0.5rem;
      max-width: 80vw;
      padding: 0.4rem;

      color: #fff;
      font-family: inherit;
      border-radius: 0.75rem;

    }

    :root {
      --shared-p-font-size: clamp(0.5rem, 1vw, 0.8rem);
      --smaller-p-font-size: clamp(0.4rem, 0.9vw, 0.7rem);
      /* Just slightly smaller */
    }

    .top-left-overlay h1 {
      font-size: clamp(0.5rem, 1.2vw, 1.8rem);
      font-weight: 500;
      margin-bottom: 0.1rem;
    }

    .top-left-overlay p {
      font-size: var(--shared-p-font-size);
      font-weight: 300;
      line-height: 1.2;
    }

    .top-left-overlay a {
      color: inherit;
      text-decoration: none;
      transition: text-decoration 0.2s ease;
    }

    .top-left-overlay a:hover {
      text-decoration: underline;
    }

    @media (max-width: 600px) {
      .top-left-overlay {
        left: 0.5rem;
        right: 0.5rem;
        max-width: 85vw;
        padding: 0.75rem;
      }
    }

    .bottom-overlays {
      position: absolute;
      bottom: 0.1rem;
      left: 1rem;
      right: 1rem;
      display: flex;
      gap: 1rem;
      justify-content: space-between;
      flex-wrap: wrap;
      align-items: flex-start;
      max-width: 100%;
      padding-bottom: 0.5rem;
    }

    .bottom-right-overlay {
      display: flex;
      flex-direction: column;
      align-items: end;
    }


    .bottom-right-overlay {
      min-width: 250px;
      flex: 1 1 auto;
      font-size: var(--smaller-p-font-size);
      font-weight: 300;
      font-family: inherit;
      color: #fff;
    }

    .bottom-left-overlay {
      min-width: 250px;
      flex: 1 1 auto;
      font-size: var(--smaller-p-font-size);
      font-weight: 300;
      font-family: inherit;
      color: #fff;
    }

    .bottom-left-overlay a,
    .bottom-right-overlay a {
      color: inherit;
      text-decoration: none;
      transition: text-decoration 0.2s ease;
    }

    .bottom-left-overlay a:hover,
    .bottom-right-overlay a:hover {
      text-decoration: underline;
    }

    .bottom-right-overlay-text {
      display: flex;
      align-items: end;
    }

    @media (max-width: 768px) {
      .bottom-overlays {

        gap: 0.4rem;
        flex-direction: column;
        align-items: flex-start;
      }

      .bottom-left-overlay,
      .bottom-right-overlay {
        flex: 1 1 100%;
        text-align: left;
        /* Add this line */
        align-items: flex-start;
        /* Useful if any flex child elements */



      }
    }



    .toggle-button {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 100;
      cursor: pointer;
      font-size: 20px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 50%;
      padding: 6px 10px;
      user-select: none;
      transition: background 0.3s;
    }

    .toggle-button:hover {
      background: rgba(255, 255, 255, 0.3);
    }


    @media (max-height: 600px) {
      .top-left-overlay h1 {
        font-size: clamp(0.35rem, 0.8vh, 0.65rem);
      }

      .top-left-overlay p {
        font-size: clamp(0.3rem, 0.7vh, 0.6rem);
      }

      .bottom-left-overlay,
      .bottom-right-overlay {
        font-size: clamp(0.28rem, 0.65vh, 0.55rem);
      }
    }
  </style>
  <!-- <script src="https://cdn.tailwindcss.com/3.4.1"></script> -->
  <script src="./tailwindcss.3.4.1.css"></script>
</head>

<body style="background: black;">
  <!-- <div id="mobile-warning" style="
  background: black;
  color: white;
  min-height: 100vh;
  width: 100vw;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  padding-top: 2rem;
  box-sizing: border-box;
  text-align: center;
">
  <div style="max-width: 90%; margin-bottom: 2rem;">
    <h2 style="font-size: 1.5rem; font-weight: bold;">This visualization is best viewed on a larger screen</h2>
    <p>Please open this page on a desktop or tablet device for the full experience.</p>
  </div>
  <img src="dreams_net.jpg" alt="Visualization Preview" style="max-width: 90%; height: auto; border: 1px solid #333;">
</div> -->
  <div id="loading-screen">
    <div style="text-align: center;">
      <div id="loading-text">
        <h1 style="font-size: 1.5rem;">Loading visualization...</h1>
      </div><br />
      <h1>Topics of our dreams</h1>
      <br />
      <p>Mapping shared dream themes from 44,000 Reddit posts</p><br />
      <div id="progress-bar"
        style="width: 80%; height: 10px; background: #333; border-radius: 5px; overflow: hidden; margin: auto;">
        <div id="progress-fill" style="height: 100%; width: 0%; background: #00ffee; transition: width 0.3s ease;">
        </div>
      </div>
    </div>
  </div>

  <div class="light" id="lightEle">
    <svg width="100vw" height="100vh" style="display: block; background: black;"></svg>
    <div class="hover-card" id="card" style="display: none; position: absolute;">
      <div class="rounded-xl overflow-hidden shadow-xl w-[240px] bg-white">
        <img id="card-img" src="" alt="Person" class="w-full h-36 object-cover" />
        <div class="bg-[#4f0809] text-white px-4 py-3 space-y-2">
          <h2 id="card-title" class="text-base font-semibold leading-tight"></h2>
          <p id="card-percent" class="text-xs opacity-90 leading-none"></p>
          <p id="card-desc" class="text-xs leading-snug"></p>
          <div>
            <p class="text-xs font-semibold text-white/90 mb-1">Selected keywords</p>
            <div id="card-keywords" class="flex flex-wrap gap-1 text-[10px]"></div>
          </div>
          <div>
            <p class="text-xs font-semibold text-white/90 mb-1">Paraphrased dream excerpts</p>
            <div id="card-quotes" class="text-xs italic font-light space-y-1"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="top-left-overlay">
      <h1>This is what dreams are made out of ....</h1>
      <p>
        Our analyses of 44K self-reported dreams, from the
        <a href="https://www.reddit.com/r/Dreams/" target="_blank">
          r/Dreams
        </a> community, posted b/w Mar. 2016 to Sept. 2022, helped us uncover this underlying taxonomy of dream themes.
        Hover or tap on the nodes to explore individual themes. Dream excerpts have been paraphrased to preserve user
        privacy.
      </p>
    </div>

    <!-- Bottom Overlays Container -->
    <div class="bottom-overlays">
      <!-- Bottom Left Overlay -->
      <div class="bottom-left-overlay">
        <p>
          <a href="https://epjdatascience.springeropen.com/articles/10.1140/epjds/s13688-025-00554-w" target="_blank">
            Dream content discovery from social media using natural language processing, EPJ Data Science 14, 40 (2025)
          </a>
          <a href="https://epjdatascience.springeropen.com/articles/10.1140/epjds/s13688-025-00554-w"
            target="_blank">[Link]</a><br>
          <i>
            <a href="https://anubhabdas.com/" target="_blank">Anubhab Das</a>,
            <a href="https://x.com/miki7s/" target="_blank">Sanja ≈†ƒáepanoviƒá</a>,
            <a href="https://www.lajello.com/" target="_blank">Luca Maria Aiello</a>,
            <a href="https://www.remrama.com/" target="_blank">Remington Mallett</a>,
            <a href="http://www.deirdrebarrett.com/" target="_blank">Deirdre Barrett</a> &
            <a href="https://researchswinger.org/" target="_blank">Daniele Quercia</a>
            | Nokia Bell Labs, Cambridge
          </i>
        </p>
      </div>

      <!-- Bottom Right Overlay -->
      <div class="bottom-right-overlay">
        <p>
        <div class="bottom-right-overlay-text">
          <i>Visualization by <a href="https://www.linkedin.com/in/anubhabdaserrr/" target="_blank">Anubhab
              Das</a> &
            <a href="https://www.linkedin.com/in/abhishekkdev/" target="_blank">Abhishek
              Kumar</a></i><br>
        </div>
        <i>Special thanks to <a href="https://www.linkedin.com/in/renakuai/" target="_blank">Rena Kuai</a> for letting
          us use her
          <a href="https://codepen.io/rkuai/pen/ExLbPWG/" target="_blank">Twinkling Stars</a> background.</i>
        </p>
      </div>
    </div>

    </p>
  </div>
  <div class="toggle-button" title="Minimize annotations" onclick="toggleText(this)">
    üëÅÔ∏è
  </div>
  </div>


  <!-- <script>
  function isMobileDevice() {
    return (window.innerWidth < 768 || /Mobi|Android/i.test(navigator.userAgent));
  }

  window.addEventListener("DOMContentLoaded", function () {
    if (isMobileDevice()) {
      document.getElementById("mobile-warning").style.display = "block";
      document.getElementById("lightEle").style.display = "none";
    } else {
      document.getElementById("main-visualization").style.display = "block";
    }
  });
</script> -->



  <script>
    function setRealViewportHeight() {
      const vh = window.innerHeight * 0.01;
      document.documentElement.style.setProperty('--vh', `${vh}px`);
    }

    setRealViewportHeight();
    window.addEventListener('resize', setRealViewportHeight);



    let percent = 0;
    let done = false;
    const fill = document.getElementById('progress-fill');
    const loadingText = document.getElementById('loading-text');
    const loader = document.getElementById('loading-screen');

    const interval = setInterval(() => {
      if (percent < 80 && !done) {
        percent += 5;
        fill.style.width = `${percent}%`;
        loadingText.textContent = `Loading visualization... ${percent}%`;
      } else if (done) {
        percent = 100;
        fill.style.width = `100%`;
        loadingText.innerHTML = '<h1 style="font-size: 1.5rem;">Loading complete!</h1>';
        clearInterval(interval);
        setTimeout(() => {
          loader.style.display = 'none';
          document.getElementById('lightEle').style.display = 'block';
        }, 300);
      }
    }, 1000);



    const sizes = [1, 1, 2, 3, 4];

    function randomPosition(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    const body = document.querySelector(".body");

    for (let i = 0; i < 300; i++) {
      const top = randomPosition(1, 100);
      const left = randomPosition(1, 100);
      const random = Math.floor(Math.random() * sizes.length);
      const randomSize = sizes[random];
      const div = document.createElement('div');
      div.style.position = 'absolute';
      div.style.top = top + '%';
      div.style.left = left + '%';
      div.style.height = randomSize + 'px';
      div.style.width = randomSize + 'px';
      div.style.backgroundColor = "#FFFFFF";
      div.style.borderRadius = '50%';
      div.style.pointerEvents = 'none';
      if (i <= 50) div.classList.add('star1');
      if (i <= 100 && i > 50) div.classList.add('star2');
      if (i <= 150 && i > 100) div.classList.add('star3');
      if (i <= 200 && i > 150) div.classList.add('star4');
      if (i <= 250 && i > 200) div.classList.add('star5');
      if (i <= 300 && i > 250) div.classList.add('star6');
      document.querySelector('.light').prepend(div);
    }

    // === GRAPH RENDERING ===
    const svg = d3.select("svg");
    let originalNodes = JSON.parse(JSON.stringify(nodes));

    function shiftGraphInPlace(nodes, shiftX, shiftY) {
      for (let i = 0; i < nodes.length; i++) {
        nodes[i].x += shiftX;
        nodes[i].y += shiftY;
      }
    }

    function flipNodesVertically(nodes, svgHeight) {
      nodes.forEach(n => {
        n.y = svgHeight - n.y;
      });
    }

    function calculateShift(nodes, svgElement) {
      const rect = svgElement.getBoundingClientRect();
      const svgCenterX = rect.width / 2;
      const svgCenterY = rect.height / 2;
      const minX = Math.min(...nodes.map(n => n.x));
      const maxX = Math.max(...nodes.map(n => n.x));
      const minY = Math.min(...nodes.map(n => n.y));
      const maxY = Math.max(...nodes.map(n => n.y));
      const graphCenterX = (minX + maxX) / 2;
      const graphCenterY = (minY + maxY) / 2;
      return [svgCenterX - graphCenterX, svgCenterY - graphCenterY];
    }

    const labelOpacity = 0.9;

    function averageColor(rgb1, rgb2) {
      const c1 = rgb1.match(/\d+/g).map(Number);
      const c2 = rgb2.match(/\d+/g).map(Number);
      const r = Math.round((c1[0] + c2[0]) / 2);
      const g = Math.round((c1[1] + c2[1]) / 2);
      const b = Math.round((c1[2] + c2[2]) / 2);
      return `rgba(${r}, ${g}, ${b},0.4)`;
    }

    function renderGraph() {
      svg.selectAll("*").remove();
      const svgEl = document.querySelector("svg");

      const localNodes = JSON.parse(JSON.stringify(originalNodes));
      const svgHeight = svgEl.getBoundingClientRect().height;
      flipNodesVertically(localNodes, svgHeight);
      const [shiftX, shiftY] = calculateShift(localNodes, svgEl);
      shiftGraphInPlace(localNodes, shiftX, shiftY);
      // Calculate bounding box of shifted graph
      const minX = Math.min(...localNodes.map(n => n.x));
      const maxX = Math.max(...localNodes.map(n => n.x));
      const minY = Math.min(...localNodes.map(n => n.y));
      const maxY = Math.max(...localNodes.map(n => n.y));

      const graphWidth = maxX - minX;
      const graphHeight = maxY - minY;

      const svgWidth = svgEl.clientWidth;
      const svgHeightNew = svgEl.clientHeight;

      let paddingFactor = 1.75;
      let flag1 = false;

      // Reduce padding when in portrait mode on mobile/tablets (e.g., width < height and width < 900px)
      const isPortraitMobile = window.innerWidth < window.innerHeight; // window.innerWidth < 900 && window.innerWidth < window.innerHeight;
      if (isPortraitMobile) {
        paddingFactor = 1.25; // Reduce padding to make graph wider
      } else {
        // Landscape mode
        if (window.innerHeight < 500) {
          paddingFactor = 1.9; // Even less padding for very short landscape screens
          flag1 = true;
        }
      }
      const scaleX = svgWidth / (graphWidth * paddingFactor); // Add padding
      const scaleY = svgHeightNew / (graphHeight * paddingFactor);
      const scale = Math.min(scaleX, scaleY); // Never enlarge past 100%

      // Compute offset so graph appears centered
      const offsetX = (svgWidth - graphWidth * scale) / 2 - minX * scale;
      let offsetY = (svgHeightNew - graphHeight * scale) / 2 - minY * scale;
      if (flag1) {
        offsetY = offsetY - 30;
      }



      const scaleGroup = svg.append("g")
        .attr("class", "scale-group")
        .attr("transform", `translate(${offsetX}, ${offsetY}) scale(${scale})`);


      // Draw links
      scaleGroup.selectAll(".link")
        .data(links)
        .enter()
        .append("line")
        .attr("class", "link")
        .attr("x1", d => localNodes.find(n => n.id === d.source).x)
        .attr("y1", d => localNodes.find(n => n.id === d.source).y)
        .attr("x2", d => localNodes.find(n => n.id === d.target).x)
        .attr("y2", d => localNodes.find(n => n.id === d.target).y)
        .attr("stroke-width", d => d.width * 40)
        .attr("stroke", d => {
          const sourceNode = localNodes.find(n => n.id === d.source);
          const targetNode = localNodes.find(n => n.id === d.target);
          return averageColor(sourceNode.color, targetNode.color);
        });
      let selectedNodeId = null;
      // let lastClickTime = 0;
      // let lastHoverTime = 0;
      // const RACE_THRESHOLD = 100; // milliseconds
      const nodeElements = new Set();
      // Draw nodes
      const nodeGroup = scaleGroup.selectAll(".node")
        .data(localNodes)
        .enter()
        .append("g")
        .attr("class", "node")  // <-- Add this
        .attr("transform", d => `translate(${d.x},${d.y})`)
        .each(function () {
          nodeElements.add(this); // track each actual <g> DOM element
        })
        .on("mouseover", function (event, d) {
          //           const now = Date.now();
          // if (now - lastClickTime < RACE_THRESHOLD) {return;}
          // lastHoverTime = now;
          selectedNodeId = d.id;
          d3.select(this).select("circle").attr("fill", d3.color(d.color).darker(1.5));
          d3.select(this).raise();
          showCard(d);
          updateCardPosition(event);
          labels.filter(l => l.id === d.id)
            .transition()
            .duration(200)
            .style("opacity", 1)
            .style("font-weight", "bold");
        })
        .on("mousemove", function (event, d) {
          selectedNodeId = d.id;
          updateCardPosition(event);
          showCard(d);
        })
        .on("mouseout", function (event, d) {
          selectedNodeId = null;
          hideCard();
          d3.select(this).select("circle").attr("fill", d.color);
          labels.filter(l => l.id === d.id)
            .transition()
            .duration(200)
            .style("opacity", labelOpacity)
            .style("font-weight", "normal");
        })

      // .on("click", function (event, d) {
      //   const now = Date.now();
      // if (now - lastHoverTime < RACE_THRESHOLD) {return;}
      // lastClickTime = now;
      // event.stopPropagation();

      // // If same node is clicked again ‚Üí hide card
      // if (selectedNodeId === d.id) {
      //   hideCard();
      //         d3.select(this).select("circle").attr("fill", d.color);
      //         labels.filter(l => l.id === d.id)
      //           .transition()
      //           .duration(200)
      //           .style("opacity", labelOpacity)
      //           .style("font-weight", "normal");
      //   selectedNodeId = null;
      //   return;
      // }

      // if (selectedNodeId != null) {
      //     hideCard();
      //   const lastNode = d3.selectAll(".node").filter(n => n.id === selectedNodeId);
      //   lastNode.select("circle").attr("fill", n => n.color);

      //   labels.filter(l => l.id === selectedNodeId)
      //     .transition()
      //     .duration(200)
      //     .style("opacity", labelOpacity)
      //     .style("font-weight", "normal");
      // }



      //     selectedNodeId = d.id; 
      //         d3.select(this).select("circle").attr("fill", d3.color(d.color).darker(1.5));
      //         d3.select(this).raise();
      //         showCard(d);
      //         updateCardPosition(event);
      //         labels.filter(l => l.id === d.id)
      //           .transition()
      //           .duration(200)
      //           .style("opacity", 1)
      //           .style("font-weight", "bold");







      // selectedNodeId = d.id;

      // d3.selectAll("circle").attr("fill", n => n.color); // Reset others
      // d3.select(this).select("circle").attr("fill", d3.color(d.color).darker(1.5));

      // showCard(d);
      // updateCardPosition(event);
      // });
      // Global click to hide card
      // document.body.addEventListener("click", function () {
      //   // Check if the click target was inside a node
      //   const clickedInsideNode = event.target.closest(".node");

      //   if (!clickedInsideNode) {
      //     hideCard();
      //     selectedNodeId = null;
      //   }
      // });




      nodeGroup.append("circle")
        .attr("class", "node-border")
        .attr("r", d => d.r)
        .attr("fill", d => d.color);

      nodeGroup.append("circle")
        .attr("r", d => d.r + 3)
        .attr("fill", "#4f0809")
        .style("filter", "blur(3px)")
        .style("opacity", 0.5);

      nodeGroup.each(function (d) {
        d3.select(this)
          .append("foreignObject")
          .attr("x", -d.r * 0.8 + d.svgOffset[0])
          .attr("y", -d.r * 0.8 + d.svgOffset[1])
          .attr("width", d.r * 1.6)
          .attr("height", d.r * 1.6)
          .attr("class", "svg-icon")
          .attr("style", () => {
            const delay = Math.random() * 0.0001;
            return `animation: pulseGlow 3s ease-in-out ${delay}s infinite`;
          })
          .html(d.svg);
      });

      labels = scaleGroup.selectAll(".label")
        .data(localNodes)
        .enter()
        .append("text")
        .attr("x", d => d.x + d.labelOffset[0])
        .attr("y", d => d.y + d.labelOffset[1])
        .attr("font-weight", "normal")
        .style("font-size", d => (d.fontSize || 12) + "px")
        .style("opacity", labelOpacity)
        .attr("text-anchor", "middle")
        .attr("fill", "white")
        .each(function (d) {
          const lines = d.label_display.split("<br/>");
          lines.forEach((line, i) => {
            d3.select(this)
              .append("tspan")
              .attr("x", d.x + d.labelOffset[0])
              .attr("dy", i === 0 ? "0em" : "1.2em")
              .text(line);
          });
        });

      document.addEventListener("touchend", function (event) {
        let insideNode = false;
        // console.log(nodeElements)
        for (const nodeEl of nodeElements) {
          if (nodeEl.contains(event.target)) {
            insideNode = true;
            break;
          }
        }
        // console.log(insideNode)
        if (!insideNode) {
          hideCard();
          // console.log('lol')
          // Reset the node circle fill


          const matchedNode = d3.selectAll(".node").filter(d => d.id === selectedNodeId);

          console.log("Matched node count:", matchedNode.size()); // Should be 1

          matchedNode.select("circle").attr("fill", d => d.color);


          // Reset the label style
          labels.filter(l => l.id === selectedNodeId)
            .transition()
            .duration(200)
            .style("opacity", labelOpacity)
            .style("font-weight", "normal");



          selectedNodeId = null;
        }
      });
      hideCard();
      selectedNodeId = null;
      // console.log(nodeElements)




    }

    let labels;
    renderGraph();
    // -----
    //     function setRealViewportHeight() {
    //   const vh = window.innerHeight * 0.01;
    //   document.documentElement.style.setProperty('--vh', `${vh}px`);
    // }
    // setRealViewportHeight();

    window.addEventListener("resize", () => renderGraph());
    // window.addEventListener('resize', setRealViewportHeight);
    // -----
    function showCard(d) {
      const card = document.getElementById("card");
      const img = document.getElementById("card-img");
      const title = document.getElementById("card-title");
      const percent = document.getElementById("card-percent");
      const desc = document.getElementById("card-desc");
      const keywords = document.getElementById("card-keywords");
      const quotes = document.getElementById("card-quotes");

      card.style.display = "block";
      card.style.fontSize = "0.65rem";
      title.style.fontSize = "0.8rem";
      percent.style.fontSize = "0.6rem";
      desc.style.fontSize = "0.65rem";
      img.src = d.img;
      title.textContent = d.label.replace(/<br\/>/g, " ");
      percent.textContent = `üõèÔ∏è ${d.theme_percent}% of Reddit dreams feature this`;
      desc.textContent = d.description;

      keywords.innerHTML = "";
      (d.keywords || []).forEach(kw => {
        const span = document.createElement("span");
        span.textContent = kw;
        span.className = "bg-white/20 px-2 py-0.5 rounded-full";
        keywords.appendChild(span);
      });

      quotes.innerHTML = "";
      (d.dream_quotes_paraphrased || []).forEach(q => {
        const p = document.createElement("p");
        p.textContent = `‚Äú${q}‚Äù`;
        p.className = "border-l-4 border-white/40 pl-2";
        quotes.appendChild(p);
      });
    }

    function updateCardPosition(event) {
      const card = document.getElementById("card");
      const cardRect = card.getBoundingClientRect();
      const padding = 40;
      let x = event.pageX + padding;
      let y = event.pageY - cardRect.height / 2;

      if (x + cardRect.width > window.innerWidth) {
        x = event.pageX - cardRect.width - padding;
      }
      if (y < 0) y = padding;
      if (y + cardRect.height > window.innerHeight) {
        y = window.innerHeight - cardRect.height - padding;
      }

      card.style.left = `${x}px`;
      card.style.top = `${y}px`;
    }

    function hideCard() {
      document.getElementById("card").style.display = "none";
    }

    function toggleText(btn) {
      const topLeft = document.querySelector('.top-left-overlay');
      const bottomRight = document.querySelector('.bottom-right-overlay');
      const bottomLeft = document.querySelector('.bottom-left-overlay');
      const isVisible = topLeft.style.display !== 'none';

      topLeft.style.display = isVisible ? 'none' : 'block';
      bottomRight.style.display = isVisible ? 'none' : 'block';
      bottomLeft.style.display = isVisible ? 'none' : 'block';

      btn.title = isVisible ? 'Reveal annotations' : 'Minimize annotations';
    }



    done = true;
    if (percent >= 80) {
      fill.style.width = `100%`;
      loadingText.textContent = `Loading complete`;
      clearInterval(interval);
      setTimeout(() => {
        loader.style.display = 'none';
        document.getElementById('lightEle').style.display = 'block';
      }, 300);
    }

    // document.getElementsByClassName('scale-group')[0].innerHTML='abrewf'
    // const el = document.getElementsByClassName('scale-group')[0];
    // el.style.cssText += 'transform: scale(0.3); transform-origin: center center;';
  </script>


</body>

</html>